name: Postman CI/CD Pipeline

# GitHub Workflow Logic:
# 1. On pull request to main: Run spec-lint ‚Üí functional-tests (using feature branch code from PR)
# 2. On push to main (when PR is merged): Run spec-lint ‚Üí functional-tests ‚Üí sync-collections-to-postman (using merged main code)
#    - sync-collections-to-postman: For each collection in postman/collections/, check if it exists in the workspace by name
#      - If exists: Update the collection via Postman API
#      - If not exists: Create the collection in the workspace via Postman API

on:
  push:
    branches:
      - main  # Trigger on commits/merges to main
  pull_request:
    branches:
      - main  # Trigger on PRs targeting main

jobs:
  # Job 1: Spec Lint - Validates API schema on PRs and main branch
  spec-lint:
    name: Spec Lint
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
      
      - name: Install Postman CLI
        run: |
          curl -o- "https://dl-cli.pstmn.io/install/linux64.sh" | sh
      
      - name: Lint API Specifications
        run: |
          postman login --with-api-key ${{ secrets.POSTMAN_API_KEY }}
          
          # Lint all collections
          echo "Linting Open API Spec containeing all APIs..."
          postman spec lint openapi.json
          
  # Job 2: Functional Tests - Runs Postman collections on PRs and main branch (depends on spec-lint)
  functional-tests:
    name: Functional Tests
    runs-on: ubuntu-latest
    needs: [spec-lint]
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
      
      - name: Install Application Dependencies
        run: |
          echo "Installing application dependencies..."
          yarn install
      
      - name: Build Application
        run: |
          echo "Building NestJS application..."
          yarn build
      
      - name: Start NestJS Application
        run: |
          echo "Starting NestJS application..."
          yarn start &
          
          # Wait for the application to be ready
          echo "Waiting for application to start..."
          for i in {1..30}; do
            if curl -s http://localhost:3000/ > /dev/null; then
              echo "‚úÖ Application is ready!"
              break
            fi
            echo "Waiting... ($i/30)"
            sleep 2
          done
          
          # Verify the application is running
          curl http://localhost:3000/ || (echo "‚ùå Application failed to start" && exit 1)
      
      - name: Install Postman CLI
        run: |
          curl -o- "https://dl-cli.pstmn.io/install/linux64.sh" | sh
      
      - name: Run Collection Tests
        run: |
          postman login --with-api-key ${{ secrets.POSTMAN_API_KEY }}
          
          # Run all collections in the postman/collections folder
          echo "Running all Postman collections..."
          for collection in postman/collections/*.json; do
            if [ -f "$collection" ]; then
              echo "Running collection: $collection"
              postman collection run "$collection" -e 43110232-6231803b-1b77-460c-897c-9ff81d425538 -r cli,json
              
              # Check if the collection run was successful
              if [ $? -ne 0 ]; then
                echo "‚ùå Collection $collection failed"
                exit 1
              fi
              echo "‚úÖ Collection $collection passed"
              echo ""
            fi
          done
          
          echo "üéâ All collections passed successfully!"
      
  # Job 3: Sync Collections to Postman Workspace - Runs only on main branch after successful tests
  sync-collections-to-postman:
    name: Sync Collections to Postman Workspace (Only on Main Branch)
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main'
    needs: [functional-tests]
    
    steps:
      - name: Check if deployment should run
        run: |
          echo "‚ÑπÔ∏è  This job only runs when code is pushed to main branch"
          echo "Current branch: ${{ github.ref }}"
          echo "Event: ${{ github.event_name }}"
      
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Sync Collections to Postman Workspace
        env:
          POSTMAN_API_KEY: ${{ secrets.POSTMAN_API_KEY }}
          WORKSPACE_ID: "e59e3813-9a85-4920-9b6a-e61d784ff94c"
        run: |
          echo "üîÑ Syncing collections to Postman workspace..."
          echo "Workspace ID: $WORKSPACE_ID"
          
          # Get all collections from the specific workspace
          echo "Fetching existing collections from workspace..."
          WORKSPACE_COLLECTIONS=$(curl -s -X GET \
            "https://api.getpostman.com/collections?workspace=$WORKSPACE_ID" \
            -H "X-Api-Key: $POSTMAN_API_KEY")
          
          # Process each collection file
          for collection_file in postman/collections/*.json; do
            if [ -f "$collection_file" ]; then
              echo ""
              echo "üì¶ Processing collection: $collection_file"
              
              # Extract collection name and ID from the file
              COLLECTION_NAME=$(jq -r '.info.name' "$collection_file")
              COLLECTION_FILE_ID=$(jq -r '.info._postman_id' "$collection_file")
              
              echo "Collection name: $COLLECTION_NAME"
              echo "Collection file ID: $COLLECTION_FILE_ID"
              
              # Check if collection exists in workspace by name (returns the collection's uid and name)
              EXISTING_COLLECTION_DATA=$(echo "$WORKSPACE_COLLECTIONS" | jq -r --arg name "$COLLECTION_NAME" \
                '.collections[]? | select(.name == $name) | {uid: .uid, name: .name}')
              
              EXISTING_COLLECTION_UID=$(echo "$EXISTING_COLLECTION_DATA" | jq -r '.uid // empty')
              EXISTING_COLLECTION_NAME=$(echo "$EXISTING_COLLECTION_DATA" | jq -r '.name // empty')
              
              if [ -n "$EXISTING_COLLECTION_UID" ] && [ "$EXISTING_COLLECTION_UID" != "null" ]; then
                # Collection exists - update it using its UID
                echo "‚úèÔ∏è  Collection '$EXISTING_COLLECTION_NAME' exists in workspace (UID: $EXISTING_COLLECTION_UID)"
                echo "Updating collection using UID: $EXISTING_COLLECTION_UID"
                
                # Log original file size
                ORIGINAL_SIZE=$(wc -c < "$collection_file")
                echo "üìÑ Original collection file size: $ORIGINAL_SIZE bytes"
                
                # Wrap collection data in "collection" object and remove all Postman-generated IDs
                # Remove: info._postman_id, item[].id, item[].uid, and nested script/event IDs
                COLLECTION_DATA=$(jq -c '{collection: (. | 
                  del(.info._postman_id) | 
                  walk(if type == "object" then del(.id, .uid) else . end)
                )}' "$collection_file")
                
                # Log the endpoint and payload for debugging
                UPDATE_URL="https://api.getpostman.com/collections/$EXISTING_COLLECTION_UID"
                echo "üîó PUT Endpoint: $UPDATE_URL"
                echo "üì¶ Processed payload size: $(echo "$COLLECTION_DATA" | wc -c) bytes"
                echo "üì¶ Payload structure:"
                echo "$COLLECTION_DATA" | jq -C '. | keys'
                echo "üì¶ Collection info:"
                echo "$COLLECTION_DATA" | jq -C '.collection | {name: .info.name, has_postman_id: (.info._postman_id != null), item_count: (.item | length), has_full_items: (.item[0] != null)}'
                
                # Show first item details to verify full data
                echo "üì¶ First item preview (to verify full content):"
                echo "$COLLECTION_DATA" | jq -C '.collection.item[0] | {name: .name, has_request: (.request != null), has_event: (.event != null), event_count: (if .event then (.event | length) else 0 end)}'
                
                UPDATE_RESPONSE=$(curl -s -X PUT \
                  "$UPDATE_URL" \
                  -H "X-Api-Key: $POSTMAN_API_KEY" \
                  -H "Content-Type: application/json" \
                  -d "$COLLECTION_DATA")
                
                # Check if update was successful
                if echo "$UPDATE_RESPONSE" | jq -e '.collection' > /dev/null 2>&1; then
                  echo "‚úÖ Successfully updated collection '$COLLECTION_NAME'"
                else
                  echo "‚ùå Failed to update collection '$COLLECTION_NAME'"
                  echo "Response: $UPDATE_RESPONSE"
                  exit 1
                fi
              else
                # Collection doesn't exist - create it
                echo "‚ûï Collection '$COLLECTION_NAME' doesn't exist. Creating..."
                
                # Log original file size
                ORIGINAL_SIZE=$(wc -c < "$collection_file")
                echo "üìÑ Original collection file size: $ORIGINAL_SIZE bytes"
                
                # Wrap collection data in "collection" object and remove all Postman-generated IDs
                # Remove: info._postman_id, item[].id, item[].uid, and nested script/event IDs
                COLLECTION_DATA=$(jq -c '{collection: (. | 
                  del(.info._postman_id) | 
                  walk(if type == "object" then del(.id, .uid) else . end)
                )}' "$collection_file")
                
                # Log the endpoint and payload for debugging
                CREATE_URL="https://api.getpostman.com/collections?workspace=$WORKSPACE_ID"
                echo "üîó POST Endpoint: $CREATE_URL"
                echo "üì¶ Processed payload size: $(echo "$COLLECTION_DATA" | wc -c) bytes"
                echo "üì¶ Payload structure:"
                echo "$COLLECTION_DATA" | jq -C '. | keys'
                echo "üì¶ Collection info:"
                echo "$COLLECTION_DATA" | jq -C '.collection | {name: .info.name, has_postman_id: (.info._postman_id != null), item_count: (.item | length), has_full_items: (.item[0] != null)}'
                
                # Show first item details to verify full data
                echo "üì¶ First item preview (to verify full content):"
                echo "$COLLECTION_DATA" | jq -C '.collection.item[0] | {name: .name, has_request: (.request != null), has_event: (.event != null), event_count: (if .event then (.event | length) else 0 end)}'
                
                CREATE_RESPONSE=$(curl -s -X POST \
                  "$CREATE_URL" \
                  -H "X-Api-Key: $POSTMAN_API_KEY" \
                  -H "Content-Type: application/json" \
                  -d "$COLLECTION_DATA")
                
                # Check if creation was successful
                if echo "$CREATE_RESPONSE" | jq -e '.collection' > /dev/null 2>&1; then
                  NEW_UID=$(echo "$CREATE_RESPONSE" | jq -r '.collection.uid')
                  echo "‚úÖ Successfully created collection '$COLLECTION_NAME' (UID: $NEW_UID)"
                else
                  echo "‚ùå Failed to create collection '$COLLECTION_NAME'"
                  echo "Response: $CREATE_RESPONSE"
                  exit 1
                fi
              fi
            fi
          done
          
          echo ""
          echo "üéâ All collections synced successfully!"
      
      - name: Notify Success
        if: success()
        run: |
          echo "üéâ Pipeline completed successfully!"
          echo "‚úÖ All tests passed"
          echo "‚úÖ All collections synced to Postman workspace"
